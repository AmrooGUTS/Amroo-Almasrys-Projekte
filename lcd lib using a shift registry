#include "LCD.h"
#include <cstdint>
#include <mbed.h>



LCD1602::LCD1602(PinName rs, PinName E , PinName D4, PinName D5, PinName D6, PinName D7)
    : _rs(rs), _E(E), _D4(D4), _D5(D5), _D6(D6),_D7(D7), _address(0)
{}

ShiftRegister::ShiftRegister(PinName data, PinName clk, PinName latch)
:_data(data), _clk(clk), _latch(latch)
{}
//ShiftRegister lcd(D11, D13, D10);


void LCD1602::init() {
    send_nibble(0x03);  
    ThisThread::sleep_for(5ms);
    send_nibble(0x03);
    wait_us(150);
    send_nibble(0x03);
    wait_us(150);
    send_nibble(0x02);

    send_byte(0x28, false); 
    send_byte(0x0C, false); 
    send_byte(0x06, false); 
    send_byte(0x01, false);
    ThisThread::sleep_for(2ms);
}
void LCD1602::send_nibble(uint8_t nibble) {
    _D4 = (nibble >> 0) & 0x01;
    _D5 = (nibble >> 1) & 0x01;
    _D6 = (nibble >> 2) & 0x01;
    _D7 = (nibble >> 3) & 0x01;
    pulse_latch();
}
void LCD1602::send_byte(uint8_t byte, bool is_data) {
    _E = 0;
    if (is_data)
        set_write_mode();  // RS = 1
    else
        set_command_mode();  // RS = 0

    send_nibble(byte >> 4);

    send_nibble(byte & 0x0F);
    wait_us(40);
}


void LCD1602::set_command_mode(){
    _rs = 0;
}

void LCD1602::set_write_mode(){
    _rs = 1;
}

void LCD1602::pulse_latch() {
    _E = 1;
    wait_us(1);
    _E = 0;
}

void LCD1602::set_cursor(int row, int col){
    if(row == 0){
        _address = col;
    }
    else{
        _address = 0x40 + col;
    }
    send_byte(0x80 | _address, false);
}



void LCD1602::write_char(char letter){
    send_byte(letter, true);
}

void LCD1602::print_lcd(char *string, int beginrow, int begincol){
    int i = 0;
    while(string[i] != '\0' ){
        int row = beginrow + (begincol + i) / 16;
        int col = (begincol + i) % 16;
        if (row > 1) break;
        set_cursor(row, col);
        write_char(string[i]);
        i++;
    }
}

void ShiftRegister::init_RS() {
    // Step 1: wait 15ms after power
    ThisThread::sleep_for(15ms);

    // Step 2: send 0x03 three times (using raw nibble form)
    send_nibble(0x03, false); // RS = 0
    ThisThread::sleep_for(5ms);

    send_nibble(0x03, false);
    wait_us(150);

    send_nibble(0x03, false);
    wait_us(150);

    // Step 3: set to 4-bit mode
    send_nibble(0x02, false); // 0x02 = 00000010, sets 4-bit mode

    // Now we're in 4-bit mode, send full commands
    send_command_RS(0x28); // Function set: 4-bit, 2-line, 5x8 font
    send_command_RS(0x0C); // Display on, cursor off
    send_command_RS(0x06); // Entry mode set
    send_command_RS(0x01); // Clear display
    ThisThread::sleep_for(2ms);            // Clear needs delay
}


void ShiftRegister::shift_out(uint8_t value){
    for(int i = 7; i >= 0; i--){
        _data = (value >> i) & 0x01;
        _clk = 1;
        _clk = 0;
    }
    _latch = 1;
    _latch = 0;
}
void ShiftRegister::write_SR(uint8_t letter){
    send_nibble((letter >> 4), true);
    send_nibble((letter & 0x0F), true);

}
void ShiftRegister::printSR(char* string){
    int i = 0;
    while(string[i] != '\0'){
        write_SR(string[i]);
        i++;
    }
}

void ShiftRegister::send_command_RS(uint8_t value){
    send_nibble((value >> 4) , false);
    send_nibble((value & 0x0F), false);
}

void ShiftRegister::send_nibble(uint8_t nibble, bool rs){
    
    uint8_t data = 0;

    data = data | ((nibble & 0x01) << 3); // D4 → Q3
    data = data | ((nibble & 0x02) << 3); // D5 → Q4
    data = data | ((nibble & 0x04) << 3); // D6 → Q5
    data = data | ((nibble & 0x08) << 3); // D7 → Q6

    if(rs){
        data = data | 0x02;
    }
    data = data | 0x04; //setes the E bit to 1
    shift_out(data);
    wait_us(1);

    data = data & 0xFC;
    shift_out(data);
    wait_us(1);
}

void ShiftRegister::set_cursor_RS(int row, int col){
    int adress;
    if(row == 0){
        adress = col;
    }
    else{
        adress = 0x40 + col;
    }
    send_command_RS(0x80 | adress);
}

void ShiftRegister::clear() {
    send_command_RS(0x01); // Clear display
    ThisThread::sleep_for(2ms);
}
